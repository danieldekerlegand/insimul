# Character State Snapshots & Rule Execution Tracking Implementation

## Overview

This document describes the implementation of **character state snapshots** and **rule execution sequence tracking** for Insimul simulations. These features provide complete visibility into how characters evolve and rules execute during simulation runs.

## Features Implemented

### 1. Character State Snapshots

**Purpose:** Capture the complete state of all characters at each timestep during simulation execution.

**Data Captured:**
- Core attributes (name, gender, birth year, alive status)
- Occupation and location
- Relationships (spouse, parents, children, friends)
- Custom attributes (any additional character data)

**Capabilities:**
- View character state at any timestep
- Compare states between two timesteps (diff view)
- Track character development over time
- Identify when and how characters changed

### 2. Rule Execution Sequence

**Purpose:** Track every rule that executes during simulation, along with its effects.

**Data Tracked:**
- Rule name and type (insimul/prolog/kismet)
- Timestep when rule executed
- Effects executed and their success/failure status
- Characters affected by the rule
- Narrative generated by the rule
- Execution timestamp

**Capabilities:**
- View complete chronological sequence of rule executions
- Filter by timestep
- See which effects succeeded or failed
- Track narrative generation
- Identify character interactions

## Technical Architecture

### Backend Implementation

#### Data Structures (`server/engines/unified-engine.ts`)

```typescript
interface CharacterSnapshot {
  timestep: number;
  characterId: string;
  attributes: {
    firstName: string;
    lastName: string;
    birthYear: number;
    gender: string;
    isAlive: boolean;
    occupation: string | null;
    currentLocation: string | null;
    status: string;
  };
  relationships: {
    spouseId: string | null;
    parentIds: string[];
    childIds: string[];
    friendIds: string[];
  };
  customAttributes: Record<string, any>;
}

interface RuleExecutionRecord {
  timestep: number;
  ruleId: string;
  ruleName: string;
  ruleType: string;
  conditions: any[];
  effectsExecuted: Array<{
    type: string;
    description: string;
    success: boolean;
  }>;
  charactersAffected: string[];
  narrativeGenerated: string | null;
  timestamp: Date;
}
```

#### Tracking Methods

**Character Snapshot Capture:**
```typescript
private async captureCharacterSnapshots(timestep: number): Promise<void>
```
- Called at simulation start (t=0) and after each rule execution
- Captures complete state of all characters
- Stores in Map<timestep, Map<characterId, CharacterSnapshot>>

**Rule Execution Tracking:**
```typescript
private startRuleExecution(ruleId: string, rule: any): void
private finishRuleExecution(): void
private trackEffectExecution(effect: Effect, success: boolean, description: string): void
private trackCharacterAffected(characterId: string): void
private trackNarrativeGenerated(narrative: string): void
```

**Character Diff Comparison:**
```typescript
public getCharacterDiff(
  characterId: string,
  fromTimestep: number,
  toTimestep: number
): CharacterDiff[]
```

#### Execution Flow

1. **Initialization** (t=0):
   ```typescript
   await this.captureCharacterSnapshots(0);
   ```

2. **Rule Execution Loop**:
   ```typescript
   for (const [ruleId, rule] of this.rules) {
     await this.startRuleExecution(ruleId, rule);

     for (const effect of rule.effects) {
       await this.executeEffect(effect);
       // Each effect execution calls trackEffectExecution()
       // Each character interaction calls trackCharacterAffected()
     }

     await this.finishRuleExecution();
     await this.captureCharacterSnapshots(currentTimestep);
   }
   ```

3. **Result Return**:
   ```typescript
   return {
     // ... existing fields
     characterSnapshots: this.context.characterSnapshots,
     ruleExecutionSequence: this.context.ruleExecutionSequence
   };
   ```

### Frontend Implementation

#### Components Created

**1. RuleExecutionSequenceView.tsx**

Features:
- Expandable/collapsible rule cards
- Grouped by timestep
- Color-coded by rule type (insimul/prolog/kismet)
- Shows effects with success/failure icons
- Displays characters affected
- Highlights narrative generation
- Timestamp tracking

Visual Example:
```
┌─────────────────────────────────────┐
│ Timestep 0                          │
│ ┌───────────────────────────────┐  │
│ │ ⚡ noble_succession [insimul]  │  │
│ │                                │  │
│ │ Narrative Generated:           │  │
│ │ "Princess Elara is crowned..." │  │
│ │                                │  │
│ │ Effects (3):                   │  │
│ │ ✓ generate_text: Generated... │  │
│ │ ✓ modify_attribute: Updated... │  │
│ │ ✓ trigger_event: Triggered...  │  │
│ │                                │  │
│ │ Characters: Elara, Edmund      │  │
│ └───────────────────────────────┘  │
└─────────────────────────────────────┘
```

**2. CharacterStateTimeline.tsx**

Features:
- Two tabs: "Snapshots" and "Compare States"
- Character selector dropdown
- Timestep-based timeline view
- Side-by-side state comparison
- Diff highlighting (old → new values)
- Relationship tracking
- Custom attribute display

Visual Example (Compare View):
```
┌─────────────────────────────────────────┐
│ Character: John Smith                  │
│ From t=0 → To t=50                      │
├─────────────────────────────────────────┤
│ Changes Detected (3):                   │
│ ┌─────────────────────────────────┐    │
│ │ occupation: "farmer" → "blacksmith" │ │
│ │ status: "peasant" → "craftsman"  │    │
│ │ custom.skill: 2 → 7              │    │
│ └─────────────────────────────────┘    │
│                                          │
│ ┌──────────┐         ┌──────────┐      │
│ │ State    │         │ State    │      │
│ │ at t=0   │         │ at t=50  │      │
│ │ ...      │         │ ...      │      │
│ └──────────┘         └──────────┘      │
└─────────────────────────────────────────┘
```

**3. SimulationTimelineView.tsx (Enhanced)**

Added two new tabs:
- **Rules Tab**: Embeds RuleExecutionSequenceView
- **Characters Tab**: Embeds CharacterStateTimeline

Tab layout:
```
[Past] [Present] [Future] [Rules] [Characters]
```

#### Data Flow

1. **Simulation Runs** → Backend captures snapshots and rule executions
2. **Results Returned** → `characterSnapshots` and `ruleExecutionSequence` included
3. **Frontend Receives** → modern.tsx passes data to SimulationTimelineView
4. **Map Conversion** → Convert plain object to Map structure:
   ```typescript
   characterSnapshots={
     new Map(Object.entries(simulation.results.characterSnapshots).map(([timestep, chars]) => [
       Number(timestep),
       new Map(Object.entries(chars as any))
     ]))
   }
   ```
5. **Visualization** → Components render interactive timeline views

## API Changes

### Enhanced Simulation Results

**Before:**
```json
{
  "executionTime": 125,
  "rulesExecuted": 8,
  "eventsGenerated": 5,
  "charactersAffected": 4,
  "narrative": "...",
  "truthsCreated": ["truth-id-1", "truth-id-2"]
}
```

**After:**
```json
{
  "executionTime": 125,
  "rulesExecuted": 8,
  "eventsGenerated": 5,
  "charactersAffected": 4,
  "narrative": "...",
  "truthsCreated": ["truth-id-1", "truth-id-2"],
  "ruleExecutionSequence": [
    {
      "timestep": 0,
      "ruleId": "rule-123",
      "ruleName": "noble_succession",
      "ruleType": "insimul",
      "effectsExecuted": [
        {
          "type": "generate_text",
          "description": "Generated narrative from succession_ceremony",
          "success": true
        }
      ],
      "charactersAffected": ["char-1", "char-2"],
      "narrativeGenerated": "Princess Elara is crowned...",
      "timestamp": "2025-10-25T12:00:00Z"
    }
  ],
  "characterSnapshots": {
    "0": {
      "char-1": {
        "timestep": 0,
        "characterId": "char-1",
        "attributes": {
          "firstName": "Elara",
          "lastName": "Smith",
          "birthYear": 1990,
          "gender": "female",
          "isAlive": true,
          "occupation": "princess",
          "currentLocation": "castle",
          "status": "royal"
        },
        "relationships": {
          "spouseId": null,
          "parentIds": ["char-3"],
          "childIds": [],
          "friendIds": []
        },
        "customAttributes": {
          "title": "Crown Princess"
        }
      }
    }
  }
}
```

## Use Cases

### Use Case 1: Character Development Tracking

**Scenario:** Track John Smith's progression from peasant to guild master

**Steps:**
1. Run simulation with skill_progression rules
2. Navigate to Characters tab
3. Select "John Smith" from dropdown
4. View Snapshots tab to see timeline
5. Switch to Compare tab
6. Select t=0 and t=100
7. View diff showing:
   - occupation: "farmer" → "guild master"
   - status: "peasant" → "master"
   - custom.skill: 2 → 10

### Use Case 2: Rule Execution Debugging

**Scenario:** Understand why Princess Elara became Queen

**Steps:**
1. Run simulation with succession rules
2. Navigate to Rules tab
3. Find "noble_succession" rule execution at t=15
4. Expand to see:
   - Effect: "generate_text" → Success
   - Effect: "modify_attribute" → Success
   - Narrative: "Princess Elara is crowned..."
   - Characters: Elara (affected), Edmund (deceased)

### Use Case 3: Timeline Comparison

**Scenario:** Compare world state at different points

**Steps:**
1. Run simulation
2. Use TimelineDial to scrub to t=15
3. View Present tab (events at t=15)
4. Switch to Rules tab (rules executed at t=15)
5. Switch to Characters tab
6. Compare character states before/after t=15

## Performance Considerations

### Memory Usage

- Character snapshots stored in memory during simulation
- For 100 characters × 100 timesteps = ~10,000 snapshots
- Each snapshot ~1KB = ~10MB total
- Acceptable for typical simulations (<1000 timesteps)

### Optimization Strategies

1. **Sparse Snapshots**: Only capture when changes detected
2. **Snapshot Compression**: Store diffs instead of full states
3. **Lazy Loading**: Load snapshots on-demand in frontend
4. **Pagination**: Show limited timestep ranges

### Future Enhancements

- [ ] Add snapshot compression
- [ ] Implement delta encoding
- [ ] Add snapshot pruning for long simulations
- [ ] Create character state graphs/charts
- [ ] Export timeline data to CSV
- [ ] Add event causality chains

## Testing

### Backend Tests

```typescript
// Test character snapshot capture
const snapshot = await engine.captureCharacterSnapshots(5);
expect(snapshot.get(5).size).toBe(numCharacters);

// Test rule execution tracking
await engine.startRuleExecution('rule-1', rule);
await engine.trackEffectExecution(effect, true, 'Test effect');
await engine.finishRuleExecution();
expect(engine.context.ruleExecutionSequence.length).toBe(1);

// Test character diff
const diff = engine.getCharacterDiff('char-1', 0, 10);
expect(diff.length).toBeGreaterThan(0);
```

### Frontend Tests

```typescript
// Test RuleExecutionSequenceView rendering
render(<RuleExecutionSequenceView ruleExecutionSequence={mockData} />);
expect(screen.getByText('noble_succession')).toBeInTheDocument();

// Test CharacterStateTimeline comparison
render(<CharacterStateTimeline characterSnapshots={mockSnapshots} />);
userEvent.selectOptions(screen.getByLabelText('From Timestep'), '0');
userEvent.selectOptions(screen.getByLabelText('To Timestep'), '50');
expect(screen.getByText('Changes Detected')).toBeInTheDocument();
```

## Migration Guide

### For Existing Simulations

Existing simulation results do NOT include snapshots or rule execution data. To add this data:

1. **Re-run simulations** with updated engine
2. Results will now include:
   - `ruleExecutionSequence`
   - `characterSnapshots`

### For Custom Rules

No changes needed to existing rules! Tracking is automatic for:
- `generate_text` effects
- `modify_attribute` effects
- `create_entity` effects
- `trigger_event` effects

## Conclusion

Character state snapshots and rule execution tracking provide complete transparency into simulation mechanics. Users can now:

✅ See exactly how characters evolve over time
✅ Understand which rules caused which changes
✅ Debug unexpected simulation outcomes
✅ Compare world states across timesteps
✅ Track narrative generation sources
✅ Visualize event causality chains

This completes the **Unified Timeline View** architecture, giving Insimul one of the most comprehensive simulation visualization systems available.
